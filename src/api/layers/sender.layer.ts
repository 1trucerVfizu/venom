/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/
import * as path from 'path';
import { Page } from 'puppeteer';
import { CreateConfig } from '../../config/create-config';
import {
  base64MimeType,
  downloadFileToBase64,
  evaluateAndReturn,
  fileToBase64,
  stickerSelect
} from '../helpers';
import { filenameFromMimeType } from '../helpers/filename-from-mimetype';
import { Message, SendFileResult, SendStickerResult } from '../model';
import { ChatState } from '../model/enum';
import { ListenerLayer } from './listener.layer';
import { Scope, checkValuesSender } from '../helpers/layers-interface';

let obj: Scope;

export class SenderLayer extends ListenerLayer {
  constructor(public page: Page, session?: string, options?: CreateConfig) {
    super(page, session, options);
  }

  /**
   * Send List menu
   * @example
   * ```javascript
   * let sections = [
   * {
   *   title: "Section 1",
   *   rows: [
   *     {
   *       rowId: "1",
   *       title: "Element 1",
   *       description: "Description 1",
   *     },
   *     {
   *       rowId: "2",
   *       title: "Element 2",
   *       description: "Description 2",
   *     },
   *   ]
   * },
   * {
   *   title: "Section 2",
   *   rows: [
   *     {
   *       rowId: "3",
   *       title: "Element 3",
   *       description: "Description 3",
   *     },
   *     {
   *       rowId: "4",
   *       title: "Element 4",
   *       description: "Description 4",
   *     },
   *   ]
   * },
   * ];
   * await client.sendListMenu("5511914380641@c.us", "Title", "Description", "Choose", sections);
   * ```
   * @param to the numberid xxx@c.us
   * @param title the titulo
   * @param subtitle the subtitle
   * @param description the description
   * @param buttonText the name button
   * @param menu List menu
   */
  public async sendListMenu(
    to: string,
    title: string,
    description: string,
    buttonText: string,
    menu: Array<any>
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, title, description, buttonText, menu }) => {
          let options = {
            title: title,
            buttonText: buttonText,
            description: description,
            sections: menu
          };
          return WPP.chat.sendListMessage(to, options);
        },
        { to, title, description, buttonText, menu }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Sends a text message to given chat
   * @param to chat id: xxxxx@us.c
   * @param content text message
   * @param options objects array
   */
  public async sendText(
    to: string,
    content: string,
    options?: any
  ): Promise<Object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendText';
      const type = 'string';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'content',
          type: type,
          value: content,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'options',
          type: type,
          value: options,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }
      const result = await this.page.evaluate(
        ({ to, content, options }) => {
          return WPP.chat.sendTextMessage(to, content, {
            ...options,
            waitForAck: true
          });
        },
        { to, content, options: options as any }
      );
      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Automatically sends a link with the auto generated link preview. You can also add a custom message to be added.
   * @param chatId chat id: xxxxx@us.c
   * @param url string A link, for example for youtube. e.g https://www.youtube.com/watch?v=Zi_XLOBDo_Y&list=RDEMe12_MlgO8mGFdeeftZ2nOQ&start_radio=1
   * @param text custom text as the message body, this includes the link or will be attached after the link
   */
  public async sendLinkPreview(chatId: string, url: string, text: string = '') {
    const message = text.includes(url) ? text : `${url}\n${text}`;

    const result = await evaluateAndReturn(
      this.page,
      ({ chatId, message }) => {
        return WPP.chat.sendTextMessage(chatId, message, { linkPreview: true });
      },
      { chatId, message }
    );

    return result;
  }

  /**
   * Sends image message base64
   * @param to Chat id
   * @param base64 File path, http link or base64Encoded. base64 MUST start with "data:(yourMimeType);base64,"
   * @param filename
   * @param caption
   */
  public async sendImageFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption?: string,
    quotedMessageId?: string,
    isViewOnce?: boolean
  ) {
    let mimeType = base64MimeType(base64);

    if (!mimeType) {
      const obj = {
        erro: true,
        to: to,
        text: 'Invalid base64!'
      };
      throw obj;
    }

    if (!mimeType.includes('image')) {
      const obj = {
        erro: true,
        to: to,
        text: 'Not an image, allowed formats png, jpeg and webp'
      };
      throw obj;
    }

    filename = filenameFromMimeType(filename, mimeType);

    const result = await evaluateAndReturn(
      this.page,
      async ({
        to,
        base64,
        filename,
        caption,
        quotedMessageId,
        isViewOnce
      }) => {
        const result = await WPP.chat.sendFileMessage(to, base64, {
          type: 'image',
          isViewOnce,
          filename,
          caption,
          quotedMsg: quotedMessageId,
          waitForAck: true
        });

        return {
          ack: result.ack,
          id: result.id,
          sendMsgResult: await result.sendMsgResult
        };
      },
      { to, base64, filename, caption, quotedMessageId, isViewOnce }
    );

    return result;
  }
  /**
   * Sends messages with options
   * @param to Chat id
   * @param content text string
   * @param options object
   */
  public async sendMessageOptions(
    to: any,
    content: any,
    options?: any
  ): Promise<Message> {
    return new Promise(async (resolve, reject) => {
      try {
        const messageId = await this.page.evaluate(
          ({ to, content, options }) => {
            return WAPI.sendMessageOptions(to, content, options);
          },
          { to, content, options }
        );
        const result = (await this.page.evaluate(
          (messageId: any) => WAPI.getMessageById(messageId),
          messageId
        )) as Message;
        resolve(result);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Send buttons reply
   * @example
   * ```javascript
   *  let const buttons = [
   * {
   *   "buttonId": "1",
   *   "buttonText": {
   *     "displayText": "Button 1"
   *     }
   *   },
   * {
   *   "buttonId": "2",
   *   "buttonText": {
   *     "displayText": "Button 2"
   *     }
   *   }
   * ]
   * await client.sendButtons("5511914380641@c.us", "Title", buttons, "Description");
   * ```
   * @param {string} to the numberid xxx@c.us
   * @param {string} title the titulo
   * @param {array} buttons arrays
   * @param {string} subtitle the subtitle
   */
  public async sendButtons(
    to: string,
    title: string,
    buttons: { buttonText: { displayText: string } }[],
    subtitle: string
  ): Promise<object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendButtons';
      const type = 'string';
      const obj = 'object';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'title',
          type: type,
          value: title,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'buttons',
          type: obj,
          value: buttons,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'subtitle',
          type: type,
          value: subtitle,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ to, title, buttons, subtitle }) => {
          let options = {
            useTemplateButtons: true, // False for legacy
            buttons: buttons,
            title: title, // Optional
            footer: subtitle // Optional
          };
          return WAPI.sendButtons(to, title, buttons, subtitle);
        },
        { to, title, buttons, subtitle }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }
  /**
   * Send buttons template (Not work in IPHONE)
   * @example
   * ```javascript
   * let buttons: [
   *      {
   *        url: 'https://orkestral.io/',
   *        text: 'Orkestral Cloud'
   *      },
   *      {
   *        phoneNumber: '+55 11 91438-0641',
   *        text: 'Suporte Orkestral'
   *      },
   *      {
   *        id: '1',
   *        text: 'Button 1'
   *      },
   *      {
   *        id: '2',
   *        text: 'Button 2'
   *      }
   *    ]
   *     await client.sendButtonsTemplate("5511914380641@c.us", "Title", buttons, "Description");
   * ```
   * @param {string} to the numberid xxx@c.us
   * @param {string} title the titulo
   * @param {array} buttons arrays
   * @param {string} subtitle the subtitle
   */
  public async sendButtonsTemplate(
    to: string,
    title: string,
    buttons: { buttonText: { displayText: string } }[],
    subtitle: string
  ): Promise<object> {
    return new Promise(async (resolve, reject) => {
      const typeFunction = 'sendButtons';
      const type = 'string';
      const obj = 'object';
      const check = [
        {
          param: 'to',
          type: type,
          value: to,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'title',
          type: type,
          value: title,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'buttons',
          type: obj,
          value: buttons,
          function: typeFunction,
          isUser: true
        },
        {
          param: 'subtitle',
          type: type,
          value: subtitle,
          function: typeFunction,
          isUser: true
        }
      ];
      const validating = checkValuesSender(check);
      if (typeof validating === 'object') {
        return reject(validating);
      }

      const result = await this.page.evaluate(
        ({ to, title, buttons, subtitle }) => {
          let options = {
            useTemplateButtons: true,
            createChat: true,
            buttons: buttons,
            title: title
          };
          return WPP.chat.sendTextMessage(to, subtitle, {
            ...options,
            waitForAck: true
          });
        },
        { to, title, buttons, subtitle }
      );

      if (result['erro'] == true) {
        return reject(result);
      } else {
        return resolve(result);
      }
    });
  }

  /**
   * Sends image message
   * @param to Chat id
   * @param filePath File path or http link
   * @param filename
   * @param caption
   */
  public async sendImage(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string,
    quotedMessageId?: string,
    isViewOnce?: boolean
  ) {
    let base64 = await downloadFileToBase64(filePath, [
      'image/gif',
      'image/png',
      'image/jpg',
      'image/jpeg',
      'image/webp'
    ]);

    if (!base64) {
      base64 = await fileToBase64(filePath);
    }

    if (!base64) {
      const obj = {
        erro: true,
        to: to,
        text: 'No such file or directory, open "' + filePath + '"'
      };
      throw obj;
    }

    if (!filename) {
      filename = path.basename(filePath);
    }

    return await this.sendImageFromBase64(
      to,
      base64,
      filename,
      caption,
      quotedMessageId,
      isViewOnce
    );
  }

  /**
   * Sends message with thumbnail
   * @param pathOrBase64
   * @param url
   * @param title
   * @param description
   * @param chatId
   */
  public async sendMessageWithThumb(
    pathOrBase64: string,
    url: string,
    title: string,
    description: string,
    chatId: string
  ) {
    let base64: string = '';

    if (pathOrBase64.startsWith('data:')) {
      base64 = pathOrBase64;
    } else {
      let fileContent = await downloadFileToBase64(pathOrBase64, [
        'image/gif',
        'image/png',
        'image/jpg',
        'image/jpeg',
        'image/webp'
      ]);
      if (!fileContent) {
        fileContent = await fileToBase64(pathOrBase64);
      }
      if (fileContent) {
        base64 = fileContent;
      }
    }

    if (!base64) {
      const error = new Error('Empty or invalid file or base64');
      Object.assign(error, {
        code: 'empty_file'
      });
      throw error;
    }

    const mimeInfo = base64MimeType(base64);

    if (!mimeInfo || !mimeInfo.includes('image')) {
      const error = new Error(
        'Not an image, allowed formats png, jpeg, webp and gif'
      );
      Object.assign(error, {
        code: 'invalid_image'
      });
      throw error;
    }

    const thumbnail = base64.replace(
      /^data:image\/(png|jpe?g|webp|gif);base64,/,
      ''
    );

    return evaluateAndReturn(
      this.page,
      ({ thumbnail, url, title, description, chatId }) =>
        WPP.chat.sendTextMessage(chatId, url, {
          linkPreview: {
            thumbnail: thumbnail,
            canonicalUrl: url,
            description: description,
            matchedText: url,
            title: title,
            richPreviewType: 0,
            doNotPlayInline: true
          }
        }),
      {
        thumbnail,
        url,
        title,
        description,
        chatId
      }
    );
  }

  /**
   * Replies to given mesage id of given chat id
   * @param to Chat id
   * @param content Message body
   * @param quotedMsg Message id to reply to.
   */
  public async reply(
    to: string,
    content: string,
    quotedMsg: string
  ): Promise<Message> {
    const result = await evaluateAndReturn(
      this.page,
      ({ to, content, quotedMsg }) => {
        return WPP.chat.sendTextMessage(to, content, { quotedMsg });
      },
      { to, content, quotedMsg }
    );

    const message = (await evaluateAndReturn(
      this.page,
      (messageId: any) => WAPI.getMessageById(messageId),
      result.id
    )) as Message;
    if (message['erro'] == true) {
      throw message;
    }
    return message;
  }

  /**
   * Send audio base64
   * @param to Chat id
   * @param base64 base64 data. MUST start with "data:(yourMimeType);base64,"
   * @param filename
   * @param caption
   * @param quotedMessageId Quoted message id
   */
  public async sendVoiceFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption?: string,
    quotedMessageId?: string
  ) {
    const result = await evaluateAndReturn(
      this.page,
      async ({ to, base64, filename, caption, quotedMessageId }) => {
        const result = await WPP.chat.sendFileMessage(to, base64, {
          type: 'audio',
          isPtt: true,
          filename,
          caption,
          quotedMsg: quotedMessageId,
          waitForAck: true
        });

        return {
          ack: result.ack,
          id: result.id,
          sendMsgResult: await result.sendMsgResult
        };
      },
      { to, base64, filename, caption, quotedMessageId }
    );

    return result;
  }

  /**
   * Send audio file
   * @param to Chat id
   * @param filePath Path file
   * @param filename
   * @param caption
   * @param quotedMessageId Quoted message id
   */
  public async sendVoice(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string,
    quotedMessageId?: string
  ) {
    return new Promise(async (resolve, reject) => {
      let base64 = await downloadFileToBase64(filePath, [/^audio/]),
        obj: { erro: boolean; to: string; text: string };

      if (!base64) {
        base64 = await fileToBase64(filePath);
      }

      if (!base64) {
        obj = {
          erro: true,
          to: to,
          text: 'No such file or directory, open "' + filePath + '"'
        };
        return reject(obj);
      }

      if (!filename) {
        filename = path.basename(filePath);
      }

      return this.sendVoiceFromBase64(
        to,
        base64,
        filename,
        caption,
        quotedMessageId
      )
        .then(resolve)
        .catch(reject);
    });
  }

  /**
   * Sends file
   * base64 parameter should have mime type already defined
   * @param to Chat id
   * @param base64 base64 data. MUST start with "data:(yourMimeType);base64,"
   * @param filename
   * @param caption
   */
  public async sendFileFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption?: string
  ) {
    return this.sendFile(to, base64, filename, caption);
  }

  /**
   * Sends file from path
   * @param to Chat id
   * @param pathOrBase64 File path or base64
   * @param filename The file name
   * @param caption Caption for the filename
   */
  public async sendFile(to: string, pathOrBase64: string, options?: any);

  public async sendFile(
    to: string,
    pathOrBase64: string,
    filename?: string,
    caption?: string
  );
  public async sendFile(
    to: string,
    pathOrBase64: string,
    nameOrOptions?: string | any,
    caption?: string
  ) {
    let options: any = { type: 'auto-detect' };

    if (typeof nameOrOptions === 'string') {
      options.filename = nameOrOptions;
      options.caption = caption;
    } else if (typeof nameOrOptions === 'object') {
      options = nameOrOptions;
    }

    let base64 = '';

    if (pathOrBase64.startsWith('data:')) {
      base64 = pathOrBase64;
    } else {
      let fileContent = await downloadFileToBase64(pathOrBase64);
      if (!fileContent) {
        fileContent = await fileToBase64(pathOrBase64);
      }
      if (fileContent) {
        base64 = fileContent;
      }

      if (!options.filename) {
        options.filename = path.basename(pathOrBase64);
      }
    }

    if (!base64) {
      const error = new Error('Empty or invalid file or base64');
      Object.assign(error, {
        code: 'empty_file'
      });
      throw error;
    }

    return evaluateAndReturn(
      this.page,
      async ({ to, base64, options }) => {
        const result = await WPP.chat.sendFileMessage(to, base64, options);
        return {
          ack: result.ack,
          id: result.id,
          sendMsgResult: await result.sendMsgResult
        };
      },
      { to, base64, options: options as any }
    );
  }

  /**
   * Sends a video to given chat as a gif, with caption or not, using base64
   * @param to chat id xxxxx@us.c
   * @param base64 base64 data:video/xxx;base64,xxx
   * @param filename string xxxxx
   * @param caption string xxxxx
   */
  public async sendVideoAsGif(
    to: string,
    filePath: string,
    filename?: string,
    caption?: string
  ) {
    let base64 = await downloadFileToBase64(filePath),
      obj: { erro: boolean; to: string; text: string };

    if (!base64) {
      base64 = await fileToBase64(filePath);
    }

    if (!base64) {
      obj = {
        erro: true,
        to: to,
        text: 'No such file or directory, open "' + filePath + '"'
      };
      throw obj;
    }

    if (!filename) {
      filename = path.basename(filePath);
    }

    return this.sendVideoAsGifFromBase64(to, base64, filename, caption);
  }

  /**
   * Sends a video to given chat as a gif, with caption or not, using base64
   * @param to chat id xxxxx@us.c
   * @param base64 base64 data:video/xxx;base64,xxx
   * @param filename string xxxxx
   * @param caption string xxxxx
   * @param quotedMessageId Quoted message id
   */
  public async sendVideoAsGifFromBase64(
    to: string,
    base64: string,
    filename: string,
    caption?: string,
    quotedMessageId?: string
  ) {
    const result = await evaluateAndReturn(
      this.page,
      async ({ to, base64, filename, caption, quotedMessageId }) => {
        const result = await WPP.chat.sendFileMessage(to, base64, {
          type: 'video',
          isGif: true,
          filename,
          caption,
          quotedMsg: quotedMessageId,
          waitForAck: true
        });

        return {
          ack: result.ack,
          id: result.id,
          sendMsgResult: await result.sendMsgResult
        };
      },
      { to, base64, filename, caption, quotedMessageId }
    );

    return result;
  }

  /**
   * Sends contact card to iven chat id
   * @param to Chat id
   * @param contactsId Example: 0000@c.us | [000@c.us, 1111@c.us]
   * @param name Name do contact
   */
  public async sendContactVcard(to: string, contactsId: string, name?: string) {
    const result = await evaluateAndReturn(
      this.page,
      ({ to, contactsId, name }) => {
        return WPP.chat.sendVCardContactMessage(to, {
          id: contactsId,
          name: name
        });
      },
      { to, contactsId, name }
    );
    return result;
  }

  /**
   * Send a list of contact cards
   * @param to Chat id
   * @param contacts Example: | [000@c.us, 1111@c.us]
   */
  public async sendContactVcardList(
    to: string,
    contacts: (string | { id: string; name: string })[]
  ) {
    const result = await evaluateAndReturn(
      this.page,
      ({ to, contacts }) => {
        return WPP.chat.sendVCardContactMessage(to, contacts);
      },
      { to, contacts }
    );
    return result;
  }

  /**
   * Forwards array of messages (could be ids or message objects)
   * @param to Chat id
   * @param messages Array of messages ids to be forwarded
   * @param skipMyMessages
   */
  public async forwardMessages(
    to: string,
    messages: string | string[],
    skipMyMessages: boolean
  ) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, messages, skipMyMessages }) => {
          return WAPI.forwardMessages(to, messages, skipMyMessages).catch(
            (e) => e
          );
        },
        { to, messages, skipMyMessages }
      );
      if (typeof result['erro'] !== 'undefined' && result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Generates sticker from the provided animated gif image and sends it (Send image as animated sticker)
   *  @param to chatId '000000000000@c.us'
   *  @param path image path imageBase64 A valid gif image is required. You can also send via http/https (http://www.website.com/img.gif)
   */
  public async sendImageAsStickerGif(to: string, pathOrBase64: string) {
    let base64: string = '';

    if (pathOrBase64.startsWith('data:')) {
      base64 = pathOrBase64;
    } else {
      let fileContent = await downloadFileToBase64(pathOrBase64, [
        'image/gif',
        'image/webp'
      ]);
      if (!fileContent) {
        fileContent = await fileToBase64(pathOrBase64);
      }
      if (fileContent) {
        base64 = fileContent;
      }
    }

    if (!base64) {
      const error = new Error('Empty or invalid file or base64');
      Object.assign(error, {
        code: 'empty_file'
      });
      throw error;
    }

    const mimeInfo = base64MimeType(base64);

    if (!mimeInfo || !mimeInfo.includes('image')) {
      const error = new Error('Not an image, allowed formats gig and webp');
      Object.assign(error, {
        code: 'invalid_image'
      });
      throw error;
    }

    const buff = Buffer.from(
      base64.replace(/^data:image\/(gif|webp);base64,/, ''),
      'base64'
    );

    let obj = await stickerSelect(buff, 1);

    if (!obj) {
      const error = new Error(
        'Error with sharp library, check the console log'
      );
      Object.assign(error, {
        code: 'sharp_error'
      });
      throw error;
    }

    const { webpBase64 } = obj;

    return await evaluateAndReturn(
      this.page,
      ({ to, webpBase64 }) => {
        return WPP.chat.sendFileMessage(to, webpBase64, {
          type: 'sticker'
        });
      },
      { to, webpBase64 }
    );
  }

  /**
   * Generates sticker from given image and sends it (Send Image As Sticker)
   * @param path image path imageBase64 A valid png, jpg and webp image is required. You can also send via http/https or row base64 (http://www.website.com/img.gif)
   * @param to chatId '000000000000@c.us'
   */
  public async sendImageAsSticker(to: string, pathOrBase64: string) {
    let base64: string = '';

    if (pathOrBase64.startsWith('data:')) {
      base64 = pathOrBase64;
    } else {
      let fileContent = await downloadFileToBase64(pathOrBase64, [
        'image/gif',
        'image/png',
        'image/jpg',
        'image/jpeg',
        'image/webp'
      ]);
      if (!fileContent) {
        fileContent = await fileToBase64(pathOrBase64);
      }
      if (fileContent) {
        base64 = fileContent;
      }
    }

    if (!base64) {
      const error = new Error('Empty or invalid file or base64');
      Object.assign(error, {
        code: 'empty_file'
      });
      throw error;
    }

    const mimeInfo = base64MimeType(base64);

    if (!mimeInfo || !mimeInfo.includes('image')) {
      const error = new Error(
        'Not an image, allowed formats png, jpeg, webp and gif'
      );
      Object.assign(error, {
        code: 'invalid_image'
      });
      throw error;
    }

    const buff = Buffer.from(
      base64.replace(/^data:image\/(png|jpe?g|webp|gif);base64,/, ''),
      'base64'
    );

    let obj = await stickerSelect(buff, 0);

    if (!obj) {
      const error = new Error(
        'Error with sharp library, check the console log'
      );
      Object.assign(error, {
        code: 'sharp_error'
      });
      throw error;
    }

    const { webpBase64 } = obj;

    return await evaluateAndReturn(
      this.page,
      ({ to, webpBase64 }) => {
        return WPP.chat.sendFileMessage(to, webpBase64, {
          type: 'sticker'
        });
      },
      { to, webpBase64 }
    );
  }

  /**
   * Sends location to given chat id
   * @example
   * ```javascript
   * await client.sendLocation('5511914380641@c.us', '-23.558736', '-46.661199', 'Rua Augusta,1846, São Paulo - SP')
   * ```
   * @param to Chat id
   * @param latitude Latitude
   * @param longitude Longitude
   * @param title Text caption
   */
  public async sendLocation(
    to: string,
    latitude: string,
    longitude: string,
    title: string
  ) {
    return new Promise(async (resolve, reject) => {
      const result = await this.page.evaluate(
        ({ to, latitude, longitude, title }) => {
          return WAPI.sendLocation(to, latitude, longitude, title);
        },
        { to, latitude, longitude, title }
      );
      if (result['erro'] == true) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }

  /**
   * Sets a chat status to seen. Marks all messages as ack: 3
   * @param chatId chat id: xxxxx@us.c
   */
  public async sendSeen(chatId: string) {
    return evaluateAndReturn(
      this.page,
      (chatId) => WPP.chat.markIsRead(chatId),
      chatId
    );
  }

  /**
   * Sets a audio or image view once. Marks message as played
   * @param msgId Message id: xxxxx@us.c
   */
  public async markPlayed(msgId: string) {
    return evaluateAndReturn(
      this.page,
      (msgId) => WPP.chat.markPlayed(msgId),
      msgId
    );
  }

  /**
   * Starts typing ('Typing...' state)
   * @param chatId
   * @param duration Duration um miliseconds
   */
  public async startTyping(to: string, duration?: number) {
    return evaluateAndReturn(
      this.page,
      ({ to, duration }) => WPP.chat.markIsComposing(to, duration),
      {
        to,
        duration
      }
    );
  }

  /**
   * Stops typing
   * @param to Chat id
   */
  public async stopTyping(to: string) {
    return evaluateAndReturn(this.page, ({ to }) => WPP.chat.markIsPaused(to), {
      to
    });
  }

  /**
   * Starts recording ('Recording...' state)
   * @example
   * ```javascript
   * // Keep sending recording state, use stopRecoring to finish
   * await client.startRecording('[number]@c.us');
   *
   * // Keep sending typing state for 5 seconds
   * await client.startRecording('[number]@c.us', 5000);
   * ```
   * @param to Chat Id
   * @param duration Duration um miliseconds
   */
  public async startRecording(to: string, duration?: number) {
    return evaluateAndReturn(
      this.page,
      ({ to, duration }) => WPP.chat.markIsRecording(to, duration),
      {
        to,
        duration
      }
    );
  }

  /**
   * Stops recording ('Recording...' state)
   * @param to Chat Id
   */
  public async stopRecording(to: string) {
    return evaluateAndReturn(this.page, ({ to }) => WPP.chat.markIsPaused(to), {
      to
    });
  }

  /**
   * Update your online presence
   * @param online true for available presence and false for unavailable
   */
  public async setOnlinePresence(online: boolean = true) {
    return evaluateAndReturn(
      this.page,
      ({ online }) => WPP.conn.markAvailable(online),
      {
        online
      }
    );
  }

  /**
   * Sends text with tags
   *
   */
  public async sendMentioned(to: string, message: string, mentioned: string[]) {
    return await this.page.evaluate(
      ({ to, message, mentioned }) => {
        WAPI.sendMessageMentioned(to, message, mentioned);
      },
      { to, message, mentioned }
    );
  }

  /**
   * Sets the chat state
   * @param chatState
   * @param chatId
   */
  public async setChatState(chatId: string, chatState: ChatState) {
    return await this.page.evaluate(
      ({ chatState, chatId }) => {
        WAPI.sendChatstate(chatState, chatId);
      },
      { chatState, chatId }
    );
  }
  /**
   * Send reaction to message
   * @example
   * ```javascript
   * // For send Reaction, just to send emoji
   * await client.sendReactionToMessage('[number]@c.us', '🤯');
   *
   * // to remove reacition
   * await client.startRecording('[number]@c.us', false);
   * ```
   * @param to Chat Id
   * @param duration Duration um miliseconds
   */
  public async sendReactionToMessage(msgId: string, reaction: string | false) {
    return evaluateAndReturn(
      this.page,
      ({ msgId, reaction }) => WPP.chat.sendReactionToMessage(msgId, reaction),
      {
        msgId,
        reaction
      }
    );
  }
}
